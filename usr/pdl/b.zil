"B for BOGGLE
Copyright (C) 1988 Infocom, Inc.  All rights reserved."

<DEFMAC LT ("ARGS" X) <FORM LTABLE '(PURE) !.X>>

<CONSTANT GND <LT 0>>

<GLOBAL NEXT-CUBE <>>

<GLOBAL NEXT-CUBE4
	<TABLE
	 <LTABLE (BYTE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16>
	 <LTABLE (BYTE) 2 5 6>
	 <LTABLE (BYTE) 1 3 5 6 7>
	 <LTABLE (BYTE) 2 4 6 7 8>
	 <LTABLE (BYTE) 3 7 8>
	 <LTABLE (BYTE) 1 2 6 9 10>
	 <LTABLE (BYTE) 1 2 3 5 7 9 10 11>
	 <LTABLE (BYTE) 2 3 4 6 8 10 11 12>
	 <LTABLE (BYTE) 3 4 7 11 12>
	 <LTABLE (BYTE) 5 6 10 13 14>
	 <LTABLE (BYTE) 5 6 7 9 11 13 14 15>
	 <LTABLE (BYTE) 6 7 8 10 12 14 15 16>
	 <LTABLE (BYTE) 7 8 11 15 16>
	 <LTABLE (BYTE) 9 10 14>
	 <LTABLE (BYTE) 9 10 11 13 15>
	 <LTABLE (BYTE) 10 11 12 14 16>
	 <LTABLE (BYTE) 11 12 15>>>

<GLOBAL NEXT-CUBE5 <>>

<GLOBAL CUBES <>>

<GLOBAL CUBES4
	<LTABLE 0
		<TABLE (STRING) "DOKNUT">
		<TABLE (STRING) "JAMOBQ">
		<TABLE (STRING) "BAYTIL">
		<TABLE (STRING) "MASORH">
		<TABLE (STRING) "CIAOAT">
		<TABLE (STRING) "RILUGW">
		<TABLE (STRING) "FOXBIR">
		<TABLE (STRING) "SEDWON">
		<TABLE (STRING) "GIVENT">
		<TABLE (STRING) "CALRES">
		<TABLE (STRING) "SULPET">
		<TABLE (STRING) "CEMPAD">
		<TABLE (STRING) "GUKLEY">
		<TABLE (STRING) "HENSIP">
		<TABLE (STRING) "HEYIEF">
		<TABLE (STRING) "DEZVAN">>>

<GLOBAL CUBES5
	<LTABLE 0
		<TABLE (STRING) "PRYFIS">
		<TABLE (STRING) "CLPEIT">
		<TABLE (STRING) "AEEEEM">
		<TABLE (STRING) "TOUOOT">
		<TABLE (STRING) "EOTMTT">
		<TABLE (STRING) "PRYIRR">
		<TABLE (STRING) "HNODLR">
		<TABLE (STRING) "ENSSSU">
		<TABLE (STRING) "AGUEEM">
		<TABLE (STRING) "AFSAAR">
		<TABLE (STRING) "HLODHR">
		<TABLE (STRING) "AMNEGN">
		<TABLE (STRING) "JQXBKZ">
		<TABLE (STRING) "DOTDHN">
		<TABLE (STRING) "CPTEIS">
		<TABLE (STRING) "CCSENT">
		<TABLE (STRING) "AEEAEE">
		<TABLE (STRING) "DNRHLO">
		<TABLE (STRING) "EITIIT">
		<TABLE (STRING) "AFRISY">
		<TABLE (STRING) "IITCEL">
		<TABLE (STRING) "AENDNN">
		<TABLE (STRING) "ROVGRW">
		<TABLE (STRING) "AFRAIS">
		<TABLE (STRING) "NOTOUW">>>

<GLOBAL WORD-SCORING <LTABLE 1 2 4 6 8 11>>

<ROUTINE SCORE-WORDS (I "AUX" CNT BUF (SC 0) (BCNT 0))
	 <SETG LEXVS <GET ,LEXV-TABLE .I>>
	 <REPEAT ()
		 <COND (<IGRTR? BCNT ,MAX-LINES>
			<PUT ,SCORE-TABLE .I .SC>
			<PUT ,TOTAL-TABLE
			     .I
			     <+ .SC <GET ,TOTAL-TABLE .I>>>
			<PUT ,ROUNDS-TABLE
			     .I
			     <+ <GET ,ROUNDS-TABLE .I> 1>>
			<RTRUE>)>
		 <SETG LEXV <GET ,LEXVS .BCNT>>
		 <SET CNT <GETB ,LEXV 1>>
		 <SET BUF <REST ,LEXV 2>>
		 <REPEAT ()
			 <COND (<ZERO? .CNT>
				<RETURN>)>
			 <COND (<AND <BSET? .BUF ,W-LEGAL>
				     <NOT <BSET? .BUF ,W-DUPE>>>
				<SET SC <+ .SC <WORD-SCORE .BUF>>>)>
			 <SET BUF <REST .BUF 4>>
			 <SET CNT <- .CNT 1>>>>>

<ROUTINE WORD-SCORE (BUF "AUX" (LEN <GETB .BUF 2>))
	 <SET LEN <+ 1 <- .LEN ,ENT-LEN>>>
	 <COND (<G? .LEN <GET ,WORD-SCORING 0>>
		<SET LEN <GET ,WORD-SCORING 0>>)>
	 <GET ,WORD-SCORING .LEN>>

<GLOBAL TRAY-ROT5
	<TABLE <TABLE 1 1 1>
	       <TABLE 21 -5 -4>
	       <TABLE 25 -1 -1>
	       <TABLE 5 5 4>>>

<GLOBAL TRAY-ROT4
	<TABLE <TABLE 1 1 1>
	       <TABLE 13 -4 -3>
	       <TABLE 16 -1 -1>
	       <TABLE 4 4 3>>>

<GLOBAL ROTATION 1>

<GLOBAL TRAY <>>
<GLOBAL TRAY4 <ITABLE 16 (SHARED BYTE LENGTH) 0>>
<GLOBAL TRAY5 <ITABLE 25 (SHARED BYTE LENGTH) 0>>

<GLOBAL ENT-LEN 4>

<ROUTINE PICK-ONE (FROB
		   "AUX" (L <GET .FROB 0>) (CNT <GET .FROB 1>) RND MSG RFROB)
	 <SET L <- .L 1>>
	 <SET FROB <REST .FROB 2>>
	 <SET RFROB <REST .FROB <* .CNT 2>>>
	 <SET RND <RANDOM <- .L .CNT>>>
	 <SET MSG <GET .RFROB .RND>>
	 <PUT .RFROB .RND <GET .RFROB 1>>
	 <PUT .RFROB 1 .MSG>
	 <SET CNT <+ .CNT 1>>
	 <COND (<==? .CNT .L> <SET CNT 0>)>
	 <PUT .FROB 0 .CNT>
	 .MSG>

<ROUTINE SHAKE ("AUX" TR CU (CNT 0) TLEN)
	 <SET TR ,TRAY>
	 <SET TLEN <GETB .TR 0>>
	 <SET CU ,CUBES>
	 <PUT .CU 1 0>
	 <REPEAT ()
		 <COND (<IGRTR? CNT .TLEN> <RTRUE>)>
		 <PUTB .TR
		       .CNT
		       <GETB <PICK-ONE ,CUBES>
			     <- <RANDOM 6> 1>>>>>

<GLOBAL TRAY-X 10>
<GLOBAL TRAY-Y 2>

<ROUTINE TDISPLAY ("AUX" TR TLEN L TY TX CNT TMP)
	 <SET TY ,TRAY-Y>
	 <SET TX ,TRAY-X>
	 <SET L ,ENT-LEN>
	 <SET TR ,TRAY>
	 <SET TLEN <GETB .TR 0>>
	 <SCREEN 1>
	 <CURSET .TY .TX>
	 <HLIGHT ,H-INVERSE>
	 <REPEAT ()
		 <COND (<IGRTR? CNT .TLEN>
			<HLIGHT ,H-NORMAL>
			<SCREEN 0>
			<RTRUE>)>
		 <SET TMP <GETB .TR .CNT>>
		 <TELL " ">
		 <COND (<EQUAL? .TMP !\Q>
			<TELL "Qu">)
		       (ELSE
			<TELL C .TMP " ">)>
		 <COND (<ZERO? <MOD .CNT 4>>
			<SET TY <+ .TY 1>>
			<CURSET .TY .TX>)>>>

<ROUTINE GAME4 ()
	 <SETG TRAY ,TRAY4>
	 <SETG CUBES ,CUBES4>
	 <SETG NEXT-CUBE ,NEXT-CUBE4>
	 <SETG ENT-LEN 4>>

<ROUTINE GAME5 ()
	 <SETG TRAY ,TRAY5>
	 <SETG CUBES ,CUBES5>
	 <SETG NEXT-CUBE ,NEXT-CUBE5>
	 <SETG ENT-LEN 5>>

<ROUTINE UPPERCASIFY (B "AUX" LEN (CNT 0) TMP)
	 <SET LEN <GETB .B 1>>
	 <SET CNT 0>
	 <REPEAT ()
		 <COND (<IGRTR? CNT .LEN> <RETURN>)>
		 <SET TMP <GETB <REST .B> .CNT>>
		 <COND (<AND <G=? .TMP !\a>
			     <L=? .TMP !\z>>
			<PUTB <REST .B> .CNT <- .TMP 32>>)>>>

<ROUTINE REPRINT-WORDS (I "AUX" LEN BUF (BCNT 0) INDENT (I? <>) (1ST? T))
	 <PRINT-NAME <GET ,PLAYER-TABLE .I>>
	 <TELL ": ">
	 <SETG LEXVS <GET ,LEXV-TABLE .I>>
	 <SETG INBUFS <GET ,INBUF-TABLE .I>>
	 <SET INDENT <+ 2 <GETB <GET ,PLAYER-TABLE .I> 0>>>
	 <REPEAT ()
		 <COND (<IGRTR? BCNT ,MAX-LINES>
			<COND (.1ST? <CRLF>)>
			<RTRUE>)>
		 <SETG LEXV <GET ,LEXVS .BCNT>>
		 <SETG INBUF <GET ,INBUFS .BCNT>>
		 <SET BUF <REST ,LEXV 2>>
		 <COND (<NOT <ZERO? <SET LEN <GETB ,LEXV 1>>>>
			<REPEAT ((CNT 0))
				<COND (<IGRTR? CNT .LEN>
				       <CRLF>
				       <SET I? T>
				       <RETURN>)>
				<COND (.I?
				       <SET I? <>>
				       <PRINT <GET ,SPACES .INDENT>>)>
				<SET 1ST? <>>
				<PRINT-WORD .BUF .INDENT>
				<SET BUF <REST .BUF 4>>
				<TELL " ">>)>>>

<ROUTINE PRINT-WORD (BUF "AUX" LEN BEG)
	 <SET LEN <GETB .BUF 2>>
	 <SET BEG <GETB .BUF 3>>
	 <COND (<OR <NOT <BSET? .BUF ,W-LEGAL>>
		    <BSET? .BUF ,W-DUPE>>
		<HLIGHT ,H-INVERSE>)
	       (<NOT <BSET? .BUF ,W-KNOWN>>
		<HLIGHT ,H-UNDER>)>
	 <PRINTT <REST ,INBUF .BEG> .LEN 0>
	 <HLIGHT ,H-NORMAL>>

<GLOBAL INBUFS <>>
<GLOBAL INBUF <>>
<GLOBAL LEXVS <>>
<GLOBAL LEXV <>>

<GLOBAL REMAINING 1800>

<GLOBAL WARNING-TIME 150>

<ROUTINE TIMEOUT-HANDLER ()
	 <SHOW-TIME <SETG REMAINING <- ,REMAINING ,WARNING-TIME>>>
	 <COND (<G? ,REMAINING <* 2 ,WARNING-TIME>>
		<RFALSE>)
	       (<G? ,REMAINING 0>
		<SOUND 1>
		<RFALSE>)
	       (<EQUAL? ,WARNING-TIME 150>
		<SETG WARNING-TIME 50>
		<SOUND 2>
		<RFALSE>)
	       (ELSE
		<SETG REMAINING 0>
		<RTRUE>)>>

<ROUTINE SHOW-ROUND ("AUX" TMP)
	 <SCREEN 1>
	 <CURSET <+ ,TRAY-Y 1> <+ ,TRAY-X 16>>
	 <TELL "Round ">
	 <COND (,COMPUTER? <TELL N ,ROUND>)
	       (ELSE <TELL N <GET ,ROUND-TABLE 0>>)>
	 <SCREEN 0>>

<ROUTINE SHOW-TIME (TIME "AUX" (TMP 0))
	 <SCREEN 1>
	 <CURSET <+ ,TRAY-Y 2> <+ ,TRAY-X 18>>
	 <COND (<G=? ,REMAINING 0>
		<SET TMP </ ,REMAINING 10>>)>
	 <TELL N </ .TMP 60> ":">
	 <COND (<L? <SET TMP <MOD .TMP 60>> 10>
		<TELL "0">)>
	 <TELL N .TMP>
	 <SCREEN 0>>

"check if word is makeable on tray"

<ROUTINE CHECK-WORDS (I "AUX" CNT BUF (BCNT 0))
	 <SETG LEXVS <GET ,LEXV-TABLE .I>>
	 <SETG INBUFS <GET ,INBUF-TABLE .I>>
	 <REPEAT ()
		 <COND (<IGRTR? BCNT ,MAX-LINES> <RTRUE>)>
		 <SETG LEXV <GET ,LEXVS .BCNT>>
		 <SETG INBUF <GET ,INBUFS .BCNT>>
		 <SET CNT <GETB ,LEXV 1>>
		 <SET BUF <REST ,LEXV 2>>
		 <REPEAT ()
			 <COND (<ZERO? .CNT> <RETURN>)>
			 <COND (<CHECK-WORD .BUF>
				<LOOKUP-WORD .BUF>)>
			 <SET BUF <REST .BUF 4>>
			 <SET CNT <- .CNT 1>>>>>

<ROUTINE CHECK-WORD (BUF "AUX" LEN BEG TMP)
	 <SET LEN <GETB .BUF 2>>
	 <SET BEG <GETB .BUF 3>>
	 <COND (<OR <L? .LEN ,ENT-LEN>
		    <NOT <CHECK-LETTERS .BEG .LEN 0 0>>>
		<PUT .BUF 0 ,W-BAD>
		<RFALSE>)
	       (ELSE
		<BSET .BUF ,W-LEGAL>
		,W-LEGAL)>>

<CONSTANT W-BAD 0>
<CONSTANT W-LEGAL 1>
<CONSTANT W-KNOWN 2>
<CONSTANT W-DUPE 4>
<CONSTANT W-DCHECK 8>
<CONSTANT W-CHALLENGE 16>

<ROUTINE CHECK-LETTERS (BEG LEN CUBE GONE "AUX" NXT CNT)
	 <SET NXT <GET ,NEXT-CUBE .CUBE>>
	 <SET CNT <GETB .NXT 0>>
	 <REPEAT ()
		 <COND (<CHECK-LETTER .BEG .LEN <GETB .NXT .CNT> .GONE>
			<RETURN ,W-LEGAL>)
		       (<ZERO? <SET CNT <- .CNT 1>>>
			<RETURN ,W-BAD>)>>>

<ROUTINE CHECK-LETTER (BEG LEN CUBE GONE)
	 <COND (<AND <NOT <INTBL? .CUBE ,USED .GONE 1>>
		     <EQUAL? <GETB ,INBUF .BEG>
			     <GETB ,TRAY .CUBE>>>
		<COND (<ZERO? <SET LEN <- .LEN 1>>>
		       <RTRUE>)>
		<PUTB ,USED .GONE .CUBE>
		<SET GONE <+ .GONE 1>>
		<COND (<AND <EQUAL? <GETB ,INBUF .BEG> !\Q>
			    <NOT <ZERO? .LEN>>
			    <EQUAL? <GETB ,INBUF <+ .BEG 1>> !\U>>
		       <SET BEG <+ .BEG 1>>
		       <SET LEN <- .LEN 1>>)>
		<SET BEG <+ .BEG 1>>
		<CHECK-LETTERS .BEG .LEN .CUBE .GONE>)
	       (ELSE <RFALSE>)>>

<GLOBAL USED <ITABLE 26 (BYTE) 0>>

"check if word is in dictionary"

<ROUTINE LOOKUP-WORD (BUF "AUX" LEN BEG)
	 <SET LEN <GETB .BUF 2>>
	 <SET BEG <GETB .BUF 3>>
	 <COND (<L? .LEN ,ENT-LEN>
		<PUT .BUF 0 ,W-BAD>
		<RFALSE>)>
	 <COND (<LOOKUP-LETTERS .BEG .LEN ,DICTIONARY>
		<BSET .BUF ,W-KNOWN>
		,W-KNOWN)
	       (ELSE <RFALSE>)>>

<ROUTINE LOOKUP-LETTERS (BEG LEN DICT "AUX" TMP)
	 <COND (<ZERO? .LEN>
		<COND (<ZERO? <GET .DICT 1>> <RTRUE>)
		      (ELSE <RFALSE>)>)
	       (<SET TMP <INTBL? <GETB ,INBUF .BEG> .DICT <GET .DICT 0>>>
		<SET BEG <+ .BEG 1>>
		<SET LEN <- .LEN 1>>
		<LOOKUP-LETTERS .BEG .LEN <GET .TMP 1>>)>>

<GLOBAL CWORD <ITABLE 20 (BYTE) 0>>
<GLOBAL COMPUTER-BCNT 0>

<ROUTINE NEXT-COMPUTER-INBUF ()
	 <SETG COMPUTER-BCNT <+ ,COMPUTER-BCNT 1>>
	 <SETG COMPUTER-LEXV <GET ,COMPUTER-LEXVS ,COMPUTER-BCNT>>
	 <SETG COMPUTER-INBUF <GET ,COMPUTER-INBUFS ,COMPUTER-BCNT>>>

<ROUTINE COMPUTER-WORDS ("AUX" (BCNT 0))
	 <INIT-BUFFERS ,COMPUTER-ID>
	 <SETG COMPUTER-BCNT 0>
	 <NEXT-COMPUTER-INBUF>
	 <COMPUTER-LETTERS 0 0 ,DICTIONARY <GET ,NEXT-CUBE 0>>
	 <REPEAT ()
		 <COND (<IGRTR? BCNT ,MAX-LINES> <RTRUE>)>
		 <SETG COMPUTER-INBUF <GET ,COMPUTER-INBUFS .BCNT>>
		 <SETG COMPUTER-LEXV <GET ,COMPUTER-LEXVS .BCNT>>
		 <LEX ,COMPUTER-INBUF ,COMPUTER-LEXV>
		 <REPEAT ((N <GETB ,COMPUTER-LEXV 1>) (CNT 1))
			 <COND (<ZERO? .N> <RETURN>)>
			 <PUT ,COMPUTER-LEXV .CNT 2>
			 <SET CNT <+ .CNT 2>>
			 <SET N <- .N 1>>>>>

<ROUTINE COMPUTER-LETTERS (GONE LEN DICT NTBL
			   "AUX" (N <GETB .NTBL 0>) (CNT 1) CUBE LET TMP
			   GTMP LTMP)
	 <COND (<AND <ZERO? <GET .DICT 1>>
		     <G=? .GONE ,ENT-LEN>>
		<SET TMP <GETB ,COMPUTER-INBUF 1>>
		<SET LTMP <+ .LEN 1>>
		<PUTB ,CWORD 0 .LTMP>
		<PUTB ,CWORD .LTMP !\ >
		<COND (<NOT <THERE? <REST ,CWORD> ,COMPUTER-INBUFS>>
		       <COND (<G? <+ .LTMP .TMP> 70>
			      <NEXT-COMPUTER-INBUF>
			      <SET TMP <GETB ,COMPUTER-INBUF 1>>)> 
		       <PUTB ,COMPUTER-INBUF 1 <+ .TMP .LTMP>>
		       <COPYT <REST ,CWORD>
			      <REST ,COMPUTER-INBUF <+ 2 .TMP>>
			      .LTMP>)>)>
	 <REPEAT ()
		 <SET CUBE <GETB .NTBL .CNT>>
		 <COND (<NOT <INTBL? .CUBE ,USED .GONE 1>>
			<SET LET <GETB ,TRAY .CUBE>>
			<COND (<SET TMP <INTBL? .LET .DICT <GET .DICT 0>>>
			       <PUTB ,USED .GONE .CUBE>
			       <SET GTMP <+ .GONE 1>>
			       <SET LTMP <+ .LEN 1>>
			       <PUTB ,CWORD 0 .LTMP>
			       <PUTB ,CWORD .LTMP .LET>
			       <COND (<EQUAL? .LET !\Q>
				      <SET LTMP <+ .LEN 1>>
				      <PUTB ,CWORD 0 .LTMP>
				      <PUTB ,CWORD .LTMP !\U>)>
			       <COMPUTER-LETTERS .GTMP
						 .LTMP
						 <GET .TMP 1>
						 <GET ,NEXT-CUBE .CUBE>>)>)>
		 <COND (<G? <SET CNT <+ .CNT 1>> .N>
			<RETURN>)>>>

<ROUTINE THERE? (WRD BUFS "AUX" BUF BLEN W (BCNT 0))
	 <REPEAT ()
		 <COND (<IGRTR? BCNT ,MAX-LINES> <RFALSE>)>
		 <SET BUF <GET .BUFS .BCNT>>
		 <SET BLEN <GETB .BUF 1>>
		 <SET BUF <REST .BUF 2>>
		 <PUTB .BUF .BLEN 0>
		 <SET W .WRD>
		 <REPEAT ()
			 <COND (<SET TMP <GETB .BUF 0>>
				<COND (<EQUAL? .TMP <GETB .W 0>>
				       <COND (<EQUAL? .TMP !\ > <RTRUE>)>
				       <SET W <REST .W>>
				       <SET BUF <REST .BUF>>)
				      (<SET BUF <INTBL? !\  .BUF .BLEN 1>>
				       <SET W .WRD>
				       <SET BUF <REST .BUF>>)
				      (ELSE
				       <RETURN>)>)
			       (ELSE <RETURN>)>>>>

<ROUTINE CHECK-DUPS ("AUX" L1 B1 (I1 0) NN LL1 BB1)
	 <REPEAT ()
		 <COND (<IGRTR? I1 ,MAX-PLAYERS> <RETURN>)>
		 <SET LL1 <GET ,LEXV-TABLE .I1>>
		 <SET BB1 <GET ,INBUF-TABLE .I1>>
		 <REPEAT ((CNT 0))
			 <COND (<IGRTR? CNT ,MAX-LINES> <RETURN>)>
			 <SET L1 <GET .LL1 .CNT>>
			 <SET B1 <GET .BB1 .CNT>>
			 <SET NN <GETB .L1 1>>
			 <COND (<NOT <ZERO? .NN>>
				<SET L1 <REST .L1 2>>
				<REPEAT () ;"compare word in L1 to each in L2"
					<COND (<ZERO? .NN> <RETURN>)>
					<COND (<NOT <ZERO? <GET .L1 0>>>
					       <WORD-DUPS .L1 .B1 .I1>)>
					<SET L1 <REST .L1 4>>
					<SET NN <- .NN 1>>>
				<BSET .L1 ,W-DCHECK>)>>>>

<ROUTINE WORD-DUPS (L1 B1 I1 "AUX" L2 B2 (I2 0) LL2 BB2 NN)
	 <REPEAT ()
		 <COND (<IGRTR? I2 ,MAX-PLAYERS> <RETURN>)>
		 <SET LL2 <GET ,LEXV-TABLE .I2>>
		 <SET BB2 <GET ,INBUF-TABLE .I2>>
		 <REPEAT ((CNT 0))
			 <COND (<IGRTR? CNT ,MAX-LINES> <RETURN>)>
			 <SET L2 <GET .LL2 .CNT>>
			 <SET NN <GETB .L2 1>>
			 <SET L2 <REST .L2 2>>
			 <COND (<AND <NOT <ZERO? .NN>>
				     <NOT <BSET? .L2 ,W-DCHECK>>>
				<SET B2 <GET .BB2 .CNT>>
				<REPEAT () ;"compare word in L1 to word in L2"
					<COND (<ZERO? .NN> <RETURN>)
					      (<OR <ZERO? <GET .L2 0>>
						   <EQUAL? .L1 .L2>>)
					      (<WORDS-SAME? .L1 .B1 .L2 .B2>
					       <COND (<NOT <EQUAL? .I1 .I2>>
						      <BSET .L1 ,W-DUPE>)>
					       <BSET .L2 ,W-DUPE>)>
					<SET L2 <REST .L2 4>>
					<SET NN <- .NN 1>>>)>>>>

<ROUTINE BSET (L VAL) <PUT .L 0 <BOR <GET .L 0> .VAL>>>
<ROUTINE BCLEAR (L VAL) <PUT .L 0 <BAND <GET .L 0> <BCOM .VAL>>>>
<ROUTINE BSET? (L VAL) <NOT <ZERO? <BAND <GET .L 0> .VAL>>>>

<ROUTINE WORDS-SAME? (L1 B1
		      L2 B2
		      "AUX" (S1 <GETB .L1 3>) (S2 <GETB .L2 3>)
		            (N <GETB .L1 2>) (N2 <GETB .L2 2>))
	 <COND (,DEBUG
		<TELL "comparing: ">
		<PRINTT <REST .B1 .S1> .N 0>
		<TELL " and ">
		<PRINTT <REST .B2 .S2> .N2 0>)>
	 <COND (<EQUAL? .N .N2>
		<REPEAT ()
			<COND (<ZERO? .N>
			       <COND (,DEBUG <TELL " => T" CR>)>
			       <RTRUE>)
			      (<NOT <EQUAL? <GETB .B1 .S1>
					    <GETB .B2 .S2>>>
			       <COND (,DEBUG <TELL " => <>" CR>)>
			       <RFALSE>)
			      (ELSE
			       <SET S1 <+ .S1 1>>
			       <SET S2 <+ .S2 1>>
			       <SET N <- .N 1>>)>>)
	       (ELSE <COND (,DEBUG <TELL " => <>" CR>)> <RFALSE>)>>

<GLOBAL DEBUG <>>

<OBJECT DUMMY
	(DESC "FOO")
	(FLAGS NDESCBIT)>
